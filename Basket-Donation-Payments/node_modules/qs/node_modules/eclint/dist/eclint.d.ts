/// <reference types="node" />
import * as stream from 'stream';
import * as File from 'vinyl';
import * as doc from './doc';
import EditorConfigError = require('./editor-config-error');
export declare let charsets: {
    '\u0000\u0000\u00FE\u00FF': string;
    '\u00EF\u00BB\u00BF': string;
    '\u00FE\u00FF': string;
    '\u00FF\u00FE': string;
    '\u00FF\u00FE\u0000\u0000': string;
};
export declare function configure(options: IConfigurationOptions): void;
export interface IConfigurationOptions {
    newlines?: string[];
}
export interface ISettings {
    /**
     * Set to latin1, utf-8, utf-8-bom, utf-16be or utf-16le to control the
     * character set.
     */
    charset?: string;
    /**
     * Set to tab or space to use hard tabs or soft tabs respectively.
     */
    indent_style?: string;
    /**
     * The number of columns used for each indentation level and the width
     * of soft tabs (when supported). When set to tab, the value of
     * tab_width (if specified) will be used.
     */
    indent_size?: number | string;
    /**
     * Number of columns used to represent a tab character. This defaults
     * to the value of indent_size and doesn't usually need to be specified.
     */
    tab_width?: number;
    /**
     * Removes any whitespace characters preceding newline characters.
     */
    trim_trailing_whitespace?: boolean;
    /**
     * Set to lf, cr, or crlf to control how line breaks are represented.
     */
    end_of_line?: string;
    /**
     * Ensures files ends with a newline.
     */
    insert_final_newline?: boolean;
    /**
     * Enforces the maximum number of columns you can have in a line.
     */
    max_line_length?: number;
    block_comment?: string;
    block_comment_start?: string;
    block_comment_end?: string;
}
export interface IEditorConfigLintFile extends File {
    editorconfig?: IEditorConfigLintResult;
    contents: Buffer;
}
export interface IEditorConfigLintResult {
    config: ISettings;
    errors: EditorConfigError[];
    fixed: boolean;
}
export interface IRule {
    type: string;
    resolve(settings: ISettings): string | number | boolean;
}
export interface ILineRule extends IRule {
    check(settings: ISettings, line: doc.Line): EditorConfigError;
    fix(settings: ISettings, line: doc.Line): doc.Line;
    infer(line: doc.Line): string | number | boolean;
}
export interface IDocumentRule extends IRule {
    check(settings: ISettings, doc: doc.IDocument): EditorConfigError[];
    fix(settings: ISettings, doc: doc.IDocument): doc.IDocument;
    infer(doc: doc.IDocument): string | number | boolean;
}
export interface ICommandOptions {
    settings?: ISettings;
}
export declare type Command = (options?: ICommandOptions) => NodeJS.ReadWriteStream;
export declare let ruleNames: string[];
export interface ICheckCommandOptions extends ICommandOptions {
    reporter?: (file: IEditorConfigLintFile, error: EditorConfigError) => void;
}
export declare function check(options?: ICheckCommandOptions): stream.Transform;
export declare function fix(options?: ICommandOptions): stream.Transform;
export interface InferOptions {
    /**
     * Shows the tallied score for each setting.
     */
    score?: boolean;
    /**
     * Exports file as ini file type.
     */
    ini?: boolean;
    /**
     * Adds root = true to the top of your ini file, if any.
     */
    root?: boolean;
}
export interface IScoredSetting {
    [key: string]: {
        [key: string]: number;
    };
}
export interface IScoredSettings {
    charset?: IScoredSetting;
    indent_style?: IScoredSetting;
    indent_size?: IScoredSetting;
    trim_trailing_whitespace?: IScoredSetting;
    end_of_line?: IScoredSetting;
    insert_final_newline?: IScoredSetting;
    max_line_length?: number;
}
export declare function infer(options?: InferOptions): stream.Transform;
export interface IOptions extends ICheckCommandOptions {
    fix?: boolean;
}
export default function eclint(options?: IOptions): stream.Transform;
